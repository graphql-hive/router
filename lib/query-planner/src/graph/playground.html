<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Graphviz DOT Editor</title>
        <style>
            body,
            html {
                margin: 0;
                padding: 0;
                height: 100%;
                font-family: Arial, sans-serif;
                overflow: hidden;
            }
            .container {
                display: flex;
                height: 100vh;
            }
            .editor-pane {
                flex: 1;
                display: flex;
                flex-direction: column;
                position: relative;
            }
            .editor-container {
                flex: 2;
                display: flex;
                flex-direction: column;
                position: relative;
                min-height: 100px;
            }
            .info-panel {
                flex: 1;
                border-top: 1px solid #ccc;
                overflow: auto;
                min-height: 100px;
                padding: 10px;
                font-family: monospace;
                font-size: 13px;
                background-color: #f9f9f9;
            }
            .info-panel h3 {
                margin-top: 0;
                margin-bottom: 10px;
                font-size: 14px;
                color: #333;
            }
            .info-panel ul {
                list-style-type: none;
                padding: 0;
                margin: 0;
            }
            .info-panel li {
                padding: 3px 0;
                word-break: break-all;
            }
            .edge-arrow {
                color: #666;
            }
            .edge-label {
                color: #0066cc;
                font-weight: bold;
            }
            .no-selection {
                color: #999;
                font-style: italic;
            }
            .viz-pane {
                flex: 1;
                display: flex;
                flex-direction: column;
            }
            .resizer {
                width: 8px;
                background-color: #f0f0f0;
                cursor: col-resize;
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                z-index: 10;
                border-left: 1px solid #ccc;
                border-right: 1px solid #ccc;
            }
            .resizer:hover {
                background-color: #ddd;
            }
            .CodeMirror {
                height: 100% !important;
                font-size: 14px;
            }
            .header {
                padding: 10px;
                background-color: #f5f5f5;
                border-bottom: 1px solid #ccc;
                font-weight: bold;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            /* Search component styles */
            .search-container {
                position: relative;
                margin-left: 10px;
                flex-grow: 1;
                max-width: 300px;
            }
            .search-input {
                width: 100%;
                padding: 5px 10px;
                border: 1px solid #ccc;
                border-radius: 4px;
                font-size: 14px;
            }
            .search-results {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                max-height: 200px;
                overflow-y: auto;
                background-color: white;
                border: 1px solid #ccc;
                border-top: none;
                border-radius: 0 0 4px 4px;
                z-index: 1000;
                display: none;
            }
            .search-result-item {
                padding: 8px 10px;
                cursor: pointer;
                border-bottom: 1px solid #eee;
            }
            .search-result-item:hover {
                background-color: #f0f0f0;
            }
            .search-result-item.active {
                background-color: #e0e0e0;
            }
            .search-highlight {
                background-color: #ffff99;
                font-weight: bold;
            }
            #graph-container {
                flex: 1;
                overflow: hidden;
                background-color: white;
                position: relative;
            }

            #zoom-controls {
                position: absolute;
                bottom: 10px;
                right: 10px;
                background-color: rgba(255, 255, 255, 0.8);
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 5px;
                z-index: 100;
                display: flex;
                gap: 5px;
            }

            #zoom-controls button {
                padding: 3px 8px;
                background-color: #f0f0f0;
                border: 1px solid #ccc;
                border-radius: 3px;
                cursor: pointer;
            }

            #zoom-controls button:hover {
                background-color: #e0e0e0;
            }

            #zoom-level {
                padding: 3px 8px;
                background-color: #fff;
                border: 1px solid #ccc;
                border-radius: 3px;
                min-width: 60px;
                text-align: center;
            }

            .error {
                color: red;
                padding: 10px;
                background-color: #ffeeee;
                border: 1px solid #ffcccc;
                margin: 10px;
                border-radius: 4px;
                position: absolute;
                top: 10px;
                left: 10px;
                right: 10px;
            }
            .loading {
                color: #666;
                padding: 20px;
                text-align: center;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }

            .error {
                overflow: auto;
                max-height: 300px;
                font-family: monospace;
                font-size: 13px;
                line-height: 1.4;
            }

            .error details {
                margin-top: 10px;
            }

            .error pre {
                white-space: pre-wrap;
                margin: 5px 0;
                padding: 5px;
                background: #ffe0e0;
                border-radius: 3px;
            }

            /* SVG container styling for zoom and pan */
            #svg-container {
                position: absolute;
                top: 0;
                left: 0;
                transform-origin: 0 0;
                cursor: grab;
            }

            #svg-container:active {
                cursor: grabbing;
            }

            /* Highlighting for editor line when hovering over element */
            .cm-highlighted-line {
                background-color: rgba(255, 255, 0, 0.2);
            }

            /* Highlighting for graph elements when hovering */
            .node:hover ellipse,
            .node:hover polygon,
            .node:hover rect {
                fill: #ffffcc !important;
                stroke: #ff6600 !important;
                stroke-width: 2px !important;
                cursor: pointer;
            }
            .edge:hover path,
            .edge:hover polygon {
                stroke: #ff6600 !important;
                stroke-width: 2px !important;
                cursor: pointer;
            }

            /* Styles for highlighted nodes/edges */
            .highlighted-node ellipse,
            .highlighted-node polygon,
            .highlighted-node rect {
                fill: #ffffcc !important;
                stroke: #ff6600 !important;
                stroke-width: 2px !important;
            }
            .highlighted-edge path,
            .highlighted-edge polygon {
                stroke: #ff6600 !important;
                stroke-width: 2px !important;
            }

            .tooltip {
                position: absolute;
                background-color: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 5px 8px;
                border-radius: 4px;
                font-size: 12px;
                pointer-events: none;
                z-index: 1000;
                max-width: 200px;
            }

            /* Focus mode styles */
            .focused-node ellipse,
            .focused-node polygon,
            .focused-node rect {
                fill: #ffff99 !important;
                stroke: #ff6600 !important;
                stroke-width: 3px !important;
            }
            .incoming-edge path,
            .incoming-edge polygon {
                stroke: #ff0000 !important; /* Red */
                stroke-width: 2px !important;
            }
            .outgoing-edge path,
            .outgoing-edge polygon {
                stroke: #0000ff !important; /* Blue */
                stroke-width: 2px !important;
            }
        </style>
        <!-- CodeMirror for syntax highlighting -->
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.css"
        />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.18/codemirror.min.js"></script>

        <!-- Viz.js for Graphviz rendering -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="editor-pane">
                <div class="header">DOT Graph Editor</div>
                <div class="editor-container">
                    <textarea id="editor">
digraph G {
  // Example DOT Graph
  A [label="Node A"];
  B [label="Node B"];
  C [label="Node C"];

  A -> B [label="A to B"];
  B -> C [label="B to C"];
  C -> A [label="C to A"];
}</textarea
                    >
                </div>
                <div class="info-panel" id="node-info-panel">
                    <h3>Node Information</h3>
                    <div id="node-details" class="no-selection">
                        No node selected. Click on a node to view details.
                    </div>
                </div>
                <div class="resizer" id="panel-resizer"></div>
            </div>
            <div class="viz-pane">
                <div class="header">
                    Graph Visualization
                    <div class="search-container">
                        <input
                            type="text"
                            class="search-input"
                            id="node-search"
                            placeholder="Search nodes..."
                        />
                        <div class="search-results" id="search-results"></div>
                    </div>
                </div>
                <div id="graph-container">
                    <div class="loading">Loading GraphViz...</div>
                </div>
            </div>
        </div>

        <script>
            // URL Parameter Management Functions
            function getUrlParam(name) {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get(name);
            }

            function updateUrlParam(name, value) {
                const url = new URL(window.location.href);
                if (value) {
                    url.searchParams.set(name, value);
                } else {
                    url.searchParams.delete(name);
                }
                window.history.replaceState({}, "", url);
            }

            function encodeGraphContent(content) {
                return btoa(encodeURIComponent(content));
            }

            function decodeGraphContent(encoded) {
                try {
                    return decodeURIComponent(atob(encoded));
                } catch (e) {
                    console.error("Error decoding graph content:", e);
                    return null;
                }
            }

            // Custom mode for DOT syntax highlighting
            CodeMirror.defineMode("dot", function () {
                return {
                    token: function (stream, state) {
                        // Handle comments
                        if (stream.match(/\/\//)) {
                            stream.skipToEnd();
                            return "comment";
                        }

                        if (stream.match(/\/\*/)) {
                            state.inComment = true;
                            return "comment";
                        }

                        if (state.inComment) {
                            if (stream.match(/\*\//)) {
                                state.inComment = false;
                            } else {
                                stream.skipTo("*/") || stream.skipToEnd();
                            }
                            return "comment";
                        }

                        // Handle keywords
                        if (
                            stream.match(
                                /\b(digraph|graph|subgraph|node|edge|strict)\b/i,
                            )
                        ) {
                            return "keyword";
                        }

                        // Handle attribute blocks
                        if (stream.match(/\[/)) {
                            state.inAttribute = true;
                            return "bracket";
                        }

                        if (state.inAttribute) {
                            if (stream.match(/\]/)) {
                                state.inAttribute = false;
                                return "bracket";
                            }

                            if (stream.match(/\b[a-zA-Z_][a-zA-Z0-9_]*\b/)) {
                                return "attribute";
                            }

                            if (stream.match(/=/)) {
                                return "operator";
                            }
                        }

                        // Handle operators
                        if (stream.match(/->|--|=/)) {
                            return "operator";
                        }

                        // Handle strings
                        if (stream.match(/"/)) {
                            state.inString = true;
                            return "string";
                        }

                        if (state.inString) {
                            if (stream.match(/\\"/)) {
                                return "string";
                            }
                            if (stream.match(/"/)) {
                                state.inString = false;
                                return "string";
                            }
                            stream.next();
                            return "string";
                        }

                        // Handle identifiers
                        if (stream.match(/\b[a-zA-Z_][a-zA-Z0-9_]*\b/)) {
                            return "variable";
                        }

                        stream.next();
                        return null;
                    },
                    startState: function () {
                        return {
                            inComment: false,
                            inAttribute: false,
                            inString: false,
                        };
                    },
                };
            });

            // Get initial content from URL parameter if exists
            const encodedGraph = getUrlParam("graph");
            let initialContent = document.getElementById("editor").value;

            if (encodedGraph) {
                const decodedContent = decodeGraphContent(encodedGraph);
                if (decodedContent) {
                    initialContent = decodedContent;
                    document.getElementById("editor").value = initialContent;
                }
            }

            // Initialize CodeMirror with DOT syntax highlighting
            const editor = CodeMirror.fromTextArea(
                document.getElementById("editor"),
                {
                    mode: "dot",
                    lineNumbers: true,
                    theme: "default",
                    autofocus: true,
                    lineWrapping: true,
                    value: initialContent,
                },
            );

            // Function to update URL when editor content changes
            function updateGraphUrl() {
                const content = editor.getValue();
                const encoded = encodeGraphContent(content);
                updateUrlParam("graph", encoded);
            }

            // Add event listener to update URL on blur
            editor.on("blur", updateGraphUrl);

            // Initialize Viz.js with full module and better error handling
            const viz = new Viz({
                Module: window.Viz,
                render: window.render,
            });

            // Store element to line mapping
            let elementLineMap = {};
            // Store line to elements mapping (reverse)
            let lineElementMap = {};
            let highlightedLine = null;
            let highlightedElements = [];
            let tooltip = null;

            // Variables for focus mode
            let focusedNodeId = null;
            let focusedEdges = {
                incoming: [],
                outgoing: [],
            };

            // Variables for zoom and pan
            let currentZoom = 1;
            let offsetX = 0;
            let offsetY = 0;
            let isDragging = false;
            let startX = 0;
            let startY = 0;

            // Node metadata for search functionality
            let nodeMetadata = {};

            // Function to apply transform to SVG container
            function applyTransform() {
                const svgContainer = document.getElementById("svg-container");
                if (svgContainer) {
                    svgContainer.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${currentZoom})`;
                }
            }

            // Function to update zoom level display
            function updateZoomLevelDisplay() {
                const zoomLevelEl = document.getElementById("zoom-level");
                if (zoomLevelEl) {
                    zoomLevelEl.textContent = `${Math.round(currentZoom * 100)}%`;
                }
            }

            // Function to zoom by a factor centered on a point
            function zoomAtPoint(factor, centerX, centerY) {
                // Calculate current center in SVG coordinates
                const svgX = (centerX - offsetX) / currentZoom;
                const svgY = (centerY - offsetY) / currentZoom;

                // Calculate new zoom level
                const newZoom = Math.max(
                    0.1,
                    Math.min(10, currentZoom * factor),
                );

                // Calculate new offset to keep center fixed
                offsetX = centerX - svgX * newZoom;
                offsetY = centerY - svgY * newZoom;

                // Update zoom level
                currentZoom = newZoom;

                // Apply the new transform
                applyTransform();

                // Update zoom level display
                updateZoomLevelDisplay();
            }

            // Function to zoom by factor (for buttons)
            function zoomByFactor(factor) {
                const container = document.getElementById("graph-container");
                const rect = container.getBoundingClientRect();

                // Use center of container as reference point
                const centerX = rect.width / 2;
                const centerY = rect.height / 2;

                zoomAtPoint(factor, centerX, centerY);
            }

            // Function to reset zoom
            function resetZoom() {
                currentZoom = 1;
                offsetX = 0;
                offsetY = 0;
                applyTransform();
                updateZoomLevelDisplay();
            }

            // Function to preprocess DOT source code for better compatibility
            function preprocessDotSource(dotSource) {
                // Handle escaped quotes and special characters
                let processed = dotSource;

                // Replace problematic Unicode characters if needed
                processed = processed.replace(/⊢/g, "|-");

                // Handle complex subgraph syntax with more resilience
                // No actual replacements done here, just placeholder for potential future needs

                return processed;
            }

            // Function to parse DOT code and create a mapping between elements and line numbers
            function buildElementMaps(dotSource) {
                const lines = dotSource.split("\n");
                const elementToLine = {};
                const lineToElements = {};
                const nodes = {};

                // Track current subgraph context
                let currentSubgraph = null;

                lines.forEach((line, index) => {
                    // Remove comments
                    const uncommentedLine = line
                        .replace(/\/\/.*$/, "")
                        .replace(/\/\*.*\*\//, "")
                        .trim();

                    if (!uncommentedLine) return;

                    // Track subgraph context
                    if (uncommentedLine.match(/^subgraph\s+".*"\s+{/)) {
                        currentSubgraph = uncommentedLine.match(
                            /^subgraph\s+"(.*)"\s+{/,
                        )[1];
                    } else if (uncommentedLine === "}") {
                        currentSubgraph = null;
                    }

                    // Extract label attribute if present
                    let label = null;
                    const labelMatch = uncommentedLine.match(
                        /label\s*=\s*"([^"]*)"/,
                    );
                    if (labelMatch) {
                        label = labelMatch[1];
                    }

                    // Handle quoted node IDs
                    const quotedNodeMatch = uncommentedLine.match(
                        /^"([^"]+)"\s*(\[.+\])?;?$/,
                    );
                    if (quotedNodeMatch) {
                        const nodeId = quotedNodeMatch[1];
                        elementToLine[nodeId] = index;

                        // Store node metadata for search
                        nodes[nodeId] = {
                            id: nodeId,
                            label,
                            subgraph: currentSubgraph,
                        };

                        if (!lineToElements[index]) {
                            lineToElements[index] = [];
                        }
                        lineToElements[index].push({
                            type: "node",
                            id: nodeId,
                            subgraph: currentSubgraph,
                        });
                    }

                    // Check if this is a node definition (A [label="Node A"];)
                    const nodeMatch = uncommentedLine.match(
                        /^([a-zA-Z0-9_]+)\s*(\[.+\])?;?$/,
                    );
                    if (nodeMatch) {
                        const nodeId = nodeMatch[1];
                        elementToLine[nodeId] = index;

                        // Store node metadata for search
                        nodes[nodeId] = {
                            id: nodeId,
                            label,
                            subgraph: currentSubgraph,
                        };

                        if (!lineToElements[index]) {
                            lineToElements[index] = [];
                        }
                        lineToElements[index].push({
                            type: "node",
                            id: nodeId,
                            subgraph: currentSubgraph,
                        });
                    }

                    // Check if this is an edge definition with quoted nodes ("A" -> "B")
                    const quotedEdgeMatch = uncommentedLine.match(
                        /^"([^"]+)"\s*(->|--)\s*"([^"]+)"/,
                    );
                    if (quotedEdgeMatch) {
                        const sourceNode = quotedEdgeMatch[1];
                        const targetNode = quotedEdgeMatch[3];
                        const edgeId = `${sourceNode}->${targetNode}`;

                        elementToLine[edgeId] = index;

                        if (!lineToElements[index]) {
                            lineToElements[index] = [];
                        }
                        lineToElements[index].push({
                            type: "edge",
                            id: edgeId,
                            source: sourceNode,
                            target: targetNode,
                            subgraph: currentSubgraph,
                        });
                    }

                    // Check if this is an edge definition (A -> B [label="A to B"];)
                    const edgeMatch = uncommentedLine.match(
                        /^([a-zA-Z0-9_]+)\s*(->|--)\s*([a-zA-Z0-9_]+)/,
                    );
                    if (edgeMatch) {
                        const sourceNode = edgeMatch[1];
                        const targetNode = edgeMatch[3];
                        const edgeId = `${sourceNode}->${targetNode}`;

                        elementToLine[edgeId] = index;

                        if (!lineToElements[index]) {
                            lineToElements[index] = [];
                        }
                        lineToElements[index].push({
                            type: "edge",
                            id: edgeId,
                            source: sourceNode,
                            target: targetNode,
                            subgraph: currentSubgraph,
                        });
                    }
                });

                // Store node metadata for search functionality
                nodeMetadata = nodes;

                return { elementToLine, lineToElements };
            }

            // Helper function to extract edge information
            function extractEdgeInfo() {
                const dotSource = editor.getValue();
                const lines = dotSource.split("\n");
                const edgeInfo = {};
                const nodeLabels = {};

                // First, extract all node labels
                lines.forEach((line) => {
                    const trimmedLine = line.trim();
                    // Match node definitions with labels
                    const nodeMatch = trimmedLine.match(
                        /^([a-zA-Z0-9_]+)\s*\[\s*label\s*=\s*"([^"]*)"\s*\];?$/,
                    );
                    if (nodeMatch) {
                        const nodeId = nodeMatch[1];
                        const nodeLabel = nodeMatch[2];
                        nodeLabels[nodeId] = nodeLabel;
                    }
                });

                // Then extract edge definitions with labels
                lines.forEach((line) => {
                    const trimmedLine = line.trim();
                    // Match edge definitions with optional labels
                    const edgeMatch = trimmedLine.match(
                        /^([a-zA-Z0-9_]+)\s*->\s*([a-zA-Z0-9_]+)(?:\s*\[\s*label\s*=\s*"([^"]*)"\s*\])?;?$/,
                    );
                    if (edgeMatch) {
                        const fromNode = edgeMatch[1];
                        const toNode = edgeMatch[2];
                        const edgeLabel = edgeMatch[3] || "";

                        // Store edge info indexed by from node
                        if (!edgeInfo[fromNode]) {
                            edgeInfo[fromNode] = { outgoing: [], incoming: [] };
                        }
                        edgeInfo[fromNode].outgoing.push({
                            to: toNode,
                            label: edgeLabel,
                        });

                        // Store edge info indexed by to node
                        if (!edgeInfo[toNode]) {
                            edgeInfo[toNode] = { outgoing: [], incoming: [] };
                        }
                        edgeInfo[toNode].incoming.push({
                            from: fromNode,
                            label: edgeLabel,
                        });
                    }
                });

                return { edgeInfo, nodeLabels };
            }

            // Function to update node info panel
            function updateNodeInfoPanel(nodeId) {
                const nodeInfoPanel = document.getElementById("node-details");

                if (!nodeId) {
                    nodeInfoPanel.innerHTML =
                        '<div class="no-selection">No node selected. Click on a node to view details.</div>';
                    return;
                }

                // Extract edge and node information from the DOT source
                const { edgeInfo, nodeLabels } = extractEdgeInfo();
                const nodeLabel = nodeLabels[nodeId] || nodeId;

                let html = `<strong>Selected Node:</strong> ${nodeLabel} (${nodeId})<br><br>`;

                // Check if we have edge information for this node
                if (edgeInfo[nodeId]) {
                    // Add incoming edges section
                    if (edgeInfo[nodeId].incoming.length > 0) {
                        html += "<strong>Incoming Connections:</strong><ul>";
                        edgeInfo[nodeId].incoming.forEach((edge) => {
                            const fromLabel =
                                nodeLabels[edge.from] || edge.from;
                            html += `<li><span>${fromLabel}</span> <span class="edge-arrow">--[<span class="edge-label">${edge.label}</span>]--&gt;</span> <span>${nodeLabel}</span></li>`;
                        });
                        html += "</ul>";
                    } else {
                        html +=
                            "<strong>Incoming Connections:</strong> None<br>";
                    }

                    // Add outgoing edges section
                    if (edgeInfo[nodeId].outgoing.length > 0) {
                        html +=
                            "<br /><strong>Outgoing Connections:</strong><ul>";
                        edgeInfo[nodeId].outgoing.forEach((edge) => {
                            const toLabel = nodeLabels[edge.to] || edge.to;
                            html += `<li><span>${nodeLabel}</span> <span class="edge-arrow">--[<span class="edge-label">${edge.label}</span>]--&gt;</span> <span>${toLabel}</span></li>`;
                        });
                        html += "</ul>";
                    } else {
                        html +=
                            "<strong>Outgoing Connections:</strong> None<br>";
                    }
                } else {
                    html += "No connections found for this node.";
                }

                nodeInfoPanel.innerHTML = html;
            }

            // Function to activate focus mode
            function activateFocusMode(nodeId) {
                // Clear previous focus
                deactivateFocusMode();

                // Set focused node
                focusedNodeId = nodeId;

                // Update the node info panel
                updateNodeInfoPanel(nodeId);

                // Find and highlight the node
                const svgElement = document.querySelector(
                    "#graph-container svg",
                );
                if (!svgElement) return;

                // Highlight the node
                const node = findNodeById(svgElement, nodeId);
                if (node) {
                    node.classList.add("focused-node");
                }

                // Find and highlight incoming and outgoing edges
                const edges = svgElement.querySelectorAll(".edge");
                edges.forEach((edge) => {
                    const titleEl = edge.querySelector("title");
                    if (titleEl && titleEl.textContent) {
                        const edgeDesc = titleEl.textContent.trim();
                        const parts = edgeDesc.split("->");
                        if (parts.length === 2) {
                            const fromNode = parts[0].trim();
                            const toNode = parts[1].trim();

                            if (fromNode === nodeId) {
                                // This is an outgoing edge
                                edge.classList.add("outgoing-edge");
                                focusedEdges.outgoing.push(edge);
                            } else if (toNode === nodeId) {
                                // This is an incoming edge
                                edge.classList.add("incoming-edge");
                                focusedEdges.incoming.push(edge);
                            }
                        }
                    }
                });

                // Scroll to the corresponding line in the editor
                if (elementLineMap[nodeId] !== undefined) {
                    const lineNumber = elementLineMap[nodeId];
                    highlightEditorLine(lineNumber);
                    // Always scroll to make the line visible in the center of the editor
                    editor.scrollIntoView({ line: lineNumber, ch: 0 }, 200);
                }
            }

            // Function to deactivate focus mode
            function deactivateFocusMode() {
                // Clear focused node
                if (focusedNodeId) {
                    const svgElement = document.querySelector(
                        "#graph-container svg",
                    );
                    if (svgElement) {
                        const node = findNodeById(svgElement, focusedNodeId);
                        if (node) {
                            node.classList.remove("focused-node");
                        }
                    }
                    focusedNodeId = null;

                    // Clear the node info panel
                    updateNodeInfoPanel(null);
                }

                // Clear focused edges
                focusedEdges.incoming.forEach((edge) => {
                    edge.classList.remove("incoming-edge");
                });
                focusedEdges.outgoing.forEach((edge) => {
                    edge.classList.remove("outgoing-edge");
                });
                focusedEdges.incoming = [];
                focusedEdges.outgoing = [];
            }

            // Function to attach event listeners to graph elements
            function attachEventListeners(svgElement) {
                // Create tooltip element if it doesn't exist
                if (!tooltip) {
                    tooltip = document.createElement("div");
                    tooltip.className = "tooltip";
                    tooltip.style.display = "none";
                    document.body.appendChild(tooltip);
                }

                // Find all nodes
                const nodes = svgElement.querySelectorAll(".node");
                nodes.forEach((node) => {
                    // Extract node ID from the title element
                    const titleEl = node.querySelector("title");
                    if (titleEl && titleEl.textContent) {
                        const nodeId = titleEl.textContent.trim();
                        if (elementLineMap[nodeId] !== undefined) {
                            node.addEventListener("mouseenter", () => {
                                highlightEditorLine(elementLineMap[nodeId]);
                                showTooltip(`Node: ${nodeId}`);
                            });
                            node.addEventListener(
                                "mousemove",
                                updateTooltipPosition,
                            );
                            node.addEventListener("mouseleave", () => {
                                clearHighlightedLine();
                                hideTooltip();
                            });

                            // Add click event for Focus Mode
                            node.addEventListener("click", (event) => {
                                // Toggle focus mode
                                if (focusedNodeId === nodeId) {
                                    deactivateFocusMode();
                                } else {
                                    activateFocusMode(nodeId);
                                }
                                event.stopPropagation();
                            });
                        }
                    }
                });

                // Find all edges
                const edges = svgElement.querySelectorAll(".edge");
                edges.forEach((edge) => {
                    // Extract edge nodes from the title element
                    const titleEl = edge.querySelector("title");
                    if (titleEl && titleEl.textContent) {
                        const edgeDesc = titleEl.textContent.trim();
                        const parts = edgeDesc.split("->");
                        if (parts.length === 2) {
                            const fromNode = parts[0].trim();
                            const toNode = parts[1].trim();
                            const edgeId = `${fromNode}->${toNode}`;

                            if (elementLineMap[edgeId] !== undefined) {
                                edge.addEventListener("mouseenter", () => {
                                    highlightEditorLine(elementLineMap[edgeId]);
                                    showTooltip(
                                        `Edge: ${fromNode} -> ${toNode}`,
                                    );
                                });
                                edge.addEventListener(
                                    "mousemove",
                                    updateTooltipPosition,
                                );
                                edge.addEventListener("mouseleave", () => {
                                    clearHighlightedLine();
                                    hideTooltip();
                                });
                            }
                        }
                    }
                });

                // Add click handler to the graph container to deactivate focus mode
                document
                    .getElementById("graph-container")
                    .addEventListener("click", (event) => {
                        if (
                            event.target ===
                                document.getElementById("graph-container") ||
                            event.target.id === "svg-container"
                        ) {
                            deactivateFocusMode();
                        }
                    });
            }

            // Function to highlight a line in the editor
            function highlightEditorLine(lineNumber) {
                clearHighlightedLine();
                editor.addLineClass(
                    lineNumber,
                    "background",
                    "cm-highlighted-line",
                );
                highlightedLine = lineNumber;

                // Make sure the line is visible
                const coords = editor.charCoords(
                    { line: lineNumber, ch: 0 },
                    "local",
                );
                const editorRect = editor
                    .getScrollerElement()
                    .getBoundingClientRect();
                if (coords.top < 0 || coords.top > editorRect.height) {
                    editor.scrollIntoView({ line: lineNumber, ch: 0 }, 100);
                }
            }

            // Function to clear highlighted line
            function clearHighlightedLine() {
                if (highlightedLine !== null) {
                    editor.removeLineClass(
                        highlightedLine,
                        "background",
                        "cm-highlighted-line",
                    );
                    highlightedLine = null;
                }
            }

            // Function to highlight elements in the graph
            function highlightGraphElements(elements) {
                clearHighlightedElements();

                if (!elements) return;

                const svgElement = document.querySelector(
                    "#graph-container svg",
                );
                if (!svgElement) return;

                elements.forEach((element) => {
                    if (element.type === "node") {
                        const node = findNodeById(svgElement, element.id);
                        if (node) {
                            node.classList.add("highlighted-node");
                            highlightedElements.push(node);
                        }
                    } else if (element.type === "edge") {
                        const edge = findEdgeByNodes(
                            svgElement,
                            element.source,
                            element.target,
                        );
                        if (edge) {
                            edge.classList.add("highlighted-edge");
                            highlightedElements.push(edge);
                        }
                    }
                });
            }

            // Function to clear highlighted elements
            function clearHighlightedElements() {
                highlightedElements.forEach((element) => {
                    element.classList.remove("highlighted-node");
                    element.classList.remove("highlighted-edge");
                });
                highlightedElements = [];
            }

            // Helper function to find a node by ID
            function findNodeById(svgElement, nodeId) {
                const nodes = svgElement.querySelectorAll(".node");
                for (const node of nodes) {
                    const titleEl = node.querySelector("title");
                    if (
                        titleEl &&
                        titleEl.textContent &&
                        titleEl.textContent.trim() === nodeId
                    ) {
                        return node;
                    }
                }
                return null;
            }

            // Helper function to find an edge by source and target nodes
            function findEdgeByNodes(svgElement, source, target) {
                const edges = svgElement.querySelectorAll(".edge");
                for (const edge of edges) {
                    const titleEl = edge.querySelector("title");
                    if (titleEl && titleEl.textContent) {
                        const edgeDesc = titleEl.textContent.trim();
                        if (edgeDesc === `${source}->${target}`) {
                            return edge;
                        }
                    }
                }
                return null;
            }

            // Tooltip functions
            function showTooltip(text) {
                tooltip.textContent = text;
                tooltip.style.display = "block";
            }

            function hideTooltip() {
                tooltip.style.display = "none";
            }

            function updateTooltipPosition(event) {
                tooltip.style.left = event.pageX + 10 + "px";
                tooltip.style.top = event.pageY + 10 + "px";
            }

            // Function to setup zoom and pan
            function setupZoomPan() {
                const container = document.getElementById("graph-container");

                // Add wheel event for zooming with reduced sensitivity
                container.addEventListener("wheel", function (event) {
                    event.preventDefault();

                    // Get mouse position relative to container
                    const rect = container.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;

                    // Reduce zoom sensitivity
                    const zoomSensitivity = 0.05; // Lower value means less sensitive zoom

                    // Calculate zoom factor based on wheel direction with reduced sensitivity
                    const factor =
                        event.deltaY < 0
                            ? 1 + zoomSensitivity
                            : 1 - zoomSensitivity;

                    // Zoom centered on mouse position
                    zoomAtPoint(factor, mouseX, mouseY);
                });

                // Setup pan events
                container.addEventListener("mousedown", function (event) {
                    if (event.target.closest("svg")) {
                        isDragging = true;
                        startX = event.clientX - offsetX;
                        startY = event.clientY - offsetY;
                        container.style.cursor = "grabbing";
                    }
                });

                window.addEventListener("mousemove", function (event) {
                    if (isDragging) {
                        offsetX = event.clientX - startX;
                        offsetY = event.clientY - startY;
                        applyTransform();
                    }
                });

                window.addEventListener("mouseup", function () {
                    isDragging = false;
                    container.style.cursor = "auto";
                });
            }

            // Function to render the graph
            function renderGraph() {
                // Deactivate focus mode when graph is re-rendered
                deactivateFocusMode();

                const dotSource = editor.getValue();
                const container = document.getElementById("graph-container");

                // Build element to line mapping and line to elements mapping
                const maps = buildElementMaps(dotSource);
                elementLineMap = maps.elementToLine;
                lineElementMap = maps.lineToElements;

                // Clear any previous content except loading message and zoom controls
                Array.from(container.children).forEach((child) => {
                    if (
                        !child.classList.contains("loading") &&
                        child.id !== "zoom-controls"
                    ) {
                        child.remove();
                    }
                });

                // Hide loading message once we start rendering
                const loadingEl = container.querySelector(".loading");
                if (loadingEl) loadingEl.style.display = "none";

                // Create zoom controls if they don't exist
                if (!document.getElementById("zoom-controls")) {
                    const zoomControls = document.createElement("div");
                    zoomControls.id = "zoom-controls";

                    const zoomInBtn = document.createElement("button");
                    zoomInBtn.textContent = "+";
                    zoomInBtn.title = "Zoom In";
                    zoomInBtn.onclick = () => zoomByFactor(1.1); // Keep buttons slightly more sensitive

                    const zoomOutBtn = document.createElement("button");
                    zoomOutBtn.textContent = "-";
                    zoomOutBtn.title = "Zoom Out";
                    zoomOutBtn.onclick = () => zoomByFactor(0.9); // Keep buttons slightly more sensitive

                    const resetBtn = document.createElement("button");
                    resetBtn.textContent = "Reset";
                    resetBtn.title = "Reset Zoom";
                    resetBtn.onclick = resetZoom;

                    const zoomLevel = document.createElement("div");
                    zoomLevel.id = "zoom-level";
                    zoomLevel.textContent = "100%";

                    zoomControls.appendChild(zoomOutBtn);
                    zoomControls.appendChild(zoomLevel);
                    zoomControls.appendChild(zoomInBtn);
                    zoomControls.appendChild(resetBtn);

                    container.appendChild(zoomControls);
                }

                // Add try-catch block to handle any preprocessing errors
                try {
                    // Process the DOT source to handle special characters and complex syntax
                    const processedDotSource = preprocessDotSource(dotSource);

                    // Use Viz.js to render the SVG with detailed error handling
                    viz.renderSVGElement(processedDotSource, {
                        engine: "dot",
                        format: "svg",
                    })
                        .then((svgElement) => {
                            // Remove any error messages
                            const errorElements =
                                container.querySelectorAll(".error");
                            errorElements.forEach((el) => el.remove());

                            // Create SVG container for zoom/pan
                            const svgContainer = document.createElement("div");
                            svgContainer.id = "svg-container";

                            // Add the SVG to the container
                            svgContainer.appendChild(svgElement);
                            container.appendChild(svgContainer);

                            // Initialize zoom and pan
                            setupZoomPan();

                            // Reset zoom state
                            resetZoom();

                            // Attach event listeners for highlighting
                            attachEventListeners(svgElement);
                        })
                        .catch((error) => {
                            console.error("Viz.js rendering error:", error);

                            // Display detailed error message
                            const errorDiv = document.createElement("div");
                            errorDiv.className = "error";
                            errorDiv.innerHTML = `
                        <strong>Error rendering graph:</strong> ${error.message || "Unknown error"}<br>
                        ${error.stack ? `<details><summary>Details</summary><pre>${error.stack}</pre></details>` : ""}
                    `;
                            container.appendChild(errorDiv);
                        });
                } catch (error) {
                    console.error("Graph preprocessing error:", error);

                    // Display preprocessing error
                    const errorDiv = document.createElement("div");
                    errorDiv.className = "error";
                    errorDiv.innerHTML = `
                    <strong>Error processing DOT syntax:</strong> ${error.message || "Unknown error"}<br>
                    ${error.stack ? `<details><summary>Details</summary><pre>${error.stack}</pre></details>` : ""}
                `;
                    container.appendChild(errorDiv);
                }
            }

            // Setup editor cursor line highlighting
            editor.on("cursorActivity", function () {
                const cursor = editor.getCursor();
                const lineNum = cursor.line;

                // Highlight graph elements for this line
                if (lineElementMap[lineNum]) {
                    highlightGraphElements(lineElementMap[lineNum]);
                } else {
                    clearHighlightedElements();
                }
            });

            // Add click handler for nodes in the editor
            editor.on("mousedown", function (cm, event) {
                const pos = cm.coordsChar({
                    left: event.clientX,
                    top: event.clientY,
                });
                const lineNum = pos.line;

                // Check if clicked on a node in the editor
                if (lineElementMap[lineNum]) {
                    const elements = lineElementMap[lineNum];
                    // Find nodes in the line elements
                    const node = elements.find((el) => el.type === "node");
                    if (node) {
                        // Toggle focus mode
                        if (focusedNodeId === node.id) {
                            deactivateFocusMode();
                        } else {
                            activateFocusMode(node.id);
                        }
                    }
                }
            });

            // Fuzzy search function
            function fuzzyMatch(text, query) {
                if (!query) return false;

                // Convert both to lowercase for case-insensitive matching
                text = text.toLowerCase();
                query = query.toLowerCase();

                let textIndex = 0;
                let queryIndex = 0;

                // Try to match all characters in the query with characters in the text
                while (textIndex < text.length && queryIndex < query.length) {
                    if (text[textIndex] === query[queryIndex]) {
                        queryIndex++;
                    }
                    textIndex++;
                }

                // If we matched all chars in the query, it's a match
                return queryIndex === query.length;
            }

            // Function to highlight matching parts of text
            function highlightMatches(text, query) {
                if (!query) return text;

                const lowerText = text.toLowerCase();
                const lowerQuery = query.toLowerCase();
                let result = "";
                let lastIndex = 0;

                // Find each character of the query in the text
                for (let i = 0; i < lowerQuery.length; i++) {
                    const char = lowerQuery[i];
                    const charIndex = lowerText.indexOf(char, lastIndex);

                    if (charIndex === -1) break;

                    // Add text before the matched character
                    result += text.substring(lastIndex, charIndex);
                    // Add the matched character with highlighting
                    result += `<span class="search-highlight">${text[charIndex]}</span>`;

                    lastIndex = charIndex + 1;
                }

                // Add remaining text
                result += text.substring(lastIndex);

                return result;
            }

            // Function to update search results
            function updateSearchResults(query) {
                const resultsContainer =
                    document.getElementById("search-results");
                resultsContainer.innerHTML = "";

                if (!query || query.length < 2) {
                    resultsContainer.style.display = "none";
                    return;
                }

                // Find nodes that match the query
                const matchedNodes = [];

                for (const nodeId in nodeMetadata) {
                    const node = nodeMetadata[nodeId];
                    const nodeLabel = node.label || "";

                    if (
                        fuzzyMatch(nodeId, query) ||
                        fuzzyMatch(nodeLabel, query)
                    ) {
                        matchedNodes.push({
                            id: nodeId,
                            label: nodeLabel,
                            displayText:
                                nodeId + (nodeLabel ? ` (${nodeLabel})` : ""),
                        });
                    }
                }

                // Sort results - exact matches first, then by node ID
                matchedNodes.sort((a, b) => {
                    const aExactId = a.id.toLowerCase() === query.toLowerCase();
                    const bExactId = b.id.toLowerCase() === query.toLowerCase();

                    if (aExactId && !bExactId) return -1;
                    if (!aExactId && bExactId) return 1;

                    return a.id.localeCompare(b.id);
                });

                // Show results
                if (matchedNodes.length > 0) {
                    matchedNodes.forEach((node) => {
                        const itemEl = document.createElement("div");
                        itemEl.className = "search-result-item";
                        itemEl.innerHTML = highlightMatches(
                            node.displayText,
                            query,
                        );

                        // Add click handler
                        itemEl.addEventListener("click", () => {
                            activateFocusMode(node.id);
                            document.getElementById(
                                "search-results",
                            ).style.display = "none";
                            document.getElementById("node-search").value =
                                node.displayText;
                        });

                        resultsContainer.appendChild(itemEl);
                    });

                    resultsContainer.style.display = "block";
                } else {
                    const noResults = document.createElement("div");
                    noResults.className = "search-result-item";
                    noResults.textContent = "No matching nodes found";
                    resultsContainer.appendChild(noResults);
                    resultsContainer.style.display = "block";
                }
            }

            // Setup search input handlers
            const searchInput = document.getElementById("node-search");
            const searchResults = document.getElementById("search-results");

            // Add input event handler for live search
            searchInput.addEventListener("input", () => {
                updateSearchResults(searchInput.value);
            });

            // Add focus/blur handlers for showing/hiding results
            searchInput.addEventListener("focus", () => {
                if (searchInput.value.length >= 2) {
                    searchResults.style.display = "block";
                }
            });

            // Close search results when clicking outside
            document.addEventListener("click", (event) => {
                if (!event.target.closest(".search-container")) {
                    searchResults.style.display = "none";
                }
            });

            // Keyboard navigation in search results
            let activeResultIndex = -1;

            searchInput.addEventListener("keydown", (event) => {
                const results = searchResults.querySelectorAll(
                    ".search-result-item",
                );

                if (results.length === 0) return;

                // Handle arrow up/down
                if (event.key === "ArrowDown") {
                    event.preventDefault();
                    if (activeResultIndex < results.length - 1) {
                        if (activeResultIndex >= 0) {
                            results[activeResultIndex].classList.remove(
                                "active",
                            );
                        }
                        activeResultIndex++;
                        results[activeResultIndex].classList.add("active");
                        results[activeResultIndex].scrollIntoView({
                            block: "nearest",
                        });
                    }
                } else if (event.key === "ArrowUp") {
                    event.preventDefault();
                    if (activeResultIndex > 0) {
                        results[activeResultIndex].classList.remove("active");
                        activeResultIndex--;
                        results[activeResultIndex].classList.add("active");
                        results[activeResultIndex].scrollIntoView({
                            block: "nearest",
                        });
                    }
                } else if (event.key === "Enter") {
                    event.preventDefault();
                    if (
                        activeResultIndex >= 0 &&
                        activeResultIndex < results.length
                    ) {
                        results[activeResultIndex].click();
                    } else if (results.length > 0) {
                        // If no active selection, select the first result
                        results[0].click();
                    }
                } else if (event.key === "Escape") {
                    searchResults.style.display = "none";
                    searchInput.blur();
                }
            });

            // Render the initial graph
            renderGraph();

            // Add event listener to update graph when editor changes
            editor.on("change", () => {
                // Debounce to avoid too many updates
                clearTimeout(editor.updateTimeout);
                editor.updateTimeout = setTimeout(() => {
                    renderGraph();
                    // Update URL parameter after rendering
                    updateGraphUrl();
                }, 500);
            });

            // Panel resizer functionality
            function setupPanelResizer() {
                const resizer = document.getElementById("panel-resizer");
                const container = document.querySelector(".container");
                const editorPane = document.querySelector(".editor-pane");
                const vizPane = document.querySelector(".viz-pane");

                let isResizing = false;
                let lastDownX = 0;

                // Initial panel sizes
                let editorPaneWidth = container.offsetWidth / 2;
                editorPane.style.width = editorPaneWidth + "px";
                editorPane.style.flex = "0 0 auto";

                resizer.addEventListener("mousedown", function (e) {
                    isResizing = true;
                    lastDownX = e.clientX;
                    e.preventDefault();
                });

                document.addEventListener("mousemove", function (e) {
                    if (!isResizing) return;

                    const delta = e.clientX - lastDownX;
                    lastDownX = e.clientX;

                    editorPaneWidth += delta;

                    // Enforce min/max width
                    const minWidth = 200;
                    const maxWidth = container.offsetWidth - 200;
                    editorPaneWidth = Math.max(
                        minWidth,
                        Math.min(maxWidth, editorPaneWidth),
                    );

                    editorPane.style.width = editorPaneWidth + "px";

                    // Refresh CodeMirror
                    editor.refresh();
                });

                document.addEventListener("mouseup", function () {
                    isResizing = false;
                });

                // Handle window resize
                window.addEventListener("resize", function () {
                    const maxWidth = container.offsetWidth - 200;
                    if (editorPaneWidth > maxWidth) {
                        editorPaneWidth = maxWidth;
                        editorPane.style.width = editorPaneWidth + "px";
                        editor.refresh();
                    }
                });
            }

            // Initialize panel resizer
            setupPanelResizer();
        </script>
    </body>
</html>
